import '../entities/memory_entities.dart';
import '../../data/repositories/little_brain_local_repository.dart';
import '../../data/services/local_ai_service.dart';
import '../../data/models/hive_models.dart';
import 'package:injectable/injectable.dart';

// Use Case untuk menambah memory dengan processing lokal
@injectable
class AddMemoryLocalUseCase {
  final LittleBrainLocalRepository _repository;

  AddMemoryLocalUseCase(this._repository);

  Future<void> call(String content, String source, {Map<String, dynamic>? metadata}) async {
    // Create memory object
    final memory = Memory(
      id: '', // Will be generated in repository
      content: content,
      tags: [], // Will be generated by local AI
      contexts: [], // Will be generated by local AI
      emotionalWeight: 0.5, // Will be calculated by local AI
      timestamp: DateTime.now(),
      source: source,
      metadata: metadata ?? {},
    );

    await _repository.addMemory(memory);
  }
}

// Use Case untuk mendapatkan memories yang relevan
@injectable
class GetRelevantMemoriesLocalUseCase {
  final LittleBrainLocalRepository _repository;

  GetRelevantMemoriesLocalUseCase(this._repository);

  Future<List<Memory>> call(String query, {int limit = 10}) async {
    return await _repository.getRelevantMemories(query, limit: limit);
  }
}

// Use Case untuk mendapatkan personality profile
@injectable
class GetPersonalityProfileLocalUseCase {
  final LittleBrainLocalRepository _repository;

  GetPersonalityProfileLocalUseCase(this._repository);

  Future<PersonalityProfile?> call() async {
    return await _repository.getPersonalityProfile();
  }
}

// Use Case untuk mendapatkan AI context untuk chat
@injectable
class CreateAIContextLocalUseCase {
  final LittleBrainLocalRepository _repository;
  final LocalAIService _localAI;

  CreateAIContextLocalUseCase(this._repository, this._localAI);

  Future<String> call(String currentInput) async {
    // Get relevant memories berdasarkan input
    final relevantMemories = await _repository.getRelevantMemories(currentInput, limit: 5);
    
    if (relevantMemories.isEmpty) {
      return "User is starting a new conversation. No previous context available.";
    }

    // Convert to Hive format untuk local AI processing
    final hiveMemories = relevantMemories.map((memory) => 
      HiveMemory.fromEntity(memory)
    ).toList();

    // Generate AI context
    return await _localAI.createAIContext(hiveMemories, currentInput);
  }
}

// Use Case untuk clear semua data lokal
@injectable
class ClearAllLocalDataUseCase {
  final LittleBrainLocalRepository _repository;

  ClearAllLocalDataUseCase(this._repository);

  Future<void> call() async {
    await _repository.clearAllData();
  }
}

// Use Case untuk mendapatkan memory statistics
@injectable
class GetMemoryStatisticsUseCase {
  final LittleBrainLocalRepository _repository;

  GetMemoryStatisticsUseCase(this._repository);

  Future<Map<String, dynamic>> call() async {
    return await _repository.getMemoryStatistics();
  }
}

// Use Case untuk add custom context
@injectable
class AddCustomContextUseCase {
  final LittleBrainLocalRepository _repository;

  AddCustomContextUseCase(this._repository);

  Future<void> call(String name, String type, Map<String, dynamic> parameters) async {
    final context = MemoryContext(
      id: '', // Will be generated
      name: name,
      type: type,
      parameters: parameters,
    );

    await _repository.addContext(context);
  }
}

// Use Case untuk mendapatkan memories by source
@injectable
class GetMemoriesBySourceUseCase {
  final LittleBrainLocalRepository _repository;

  GetMemoriesBySourceUseCase(this._repository);

  Future<List<Memory>> call(String source) async {
    return await _repository.getMemoriesBySource(source);
  }
}

// Use Case untuk mendapatkan memories dalam range waktu
@injectable
class GetMemoriesInRangeUseCase {
  final LittleBrainLocalRepository _repository;

  GetMemoriesInRangeUseCase(this._repository);

  Future<List<Memory>> call(DateTime start, DateTime end) async {
    return await _repository.getMemoriesInRange(start, end);
  }
}

// Use Case untuk analyze personality traits secara lokal
@injectable
class AnalyzePersonalityLocalUseCase {
  final LittleBrainLocalRepository _repository;
  final LocalAIService _localAI;

  AnalyzePersonalityLocalUseCase(this._repository, this._localAI);

  Future<Map<String, double>> call() async {
    final allMemories = await _repository.getAllMemories();
    final hiveMemories = allMemories.map((memory) => 
      HiveMemory.fromEntity(memory)
    ).toList();

    return await _localAI.analyzePersonalityTraits(hiveMemories);
  }
}

// Use Case untuk extract insights dari memories
@injectable
class ExtractInsightsUseCase {
  final LittleBrainLocalRepository _repository;

  ExtractInsightsUseCase(this._repository);

  Future<PersonalityInsights> call() async {
    final profile = await _repository.getPersonalityProfile();
    final allMemories = await _repository.getAllMemories();

    if (profile == null || allMemories.isEmpty) {
      return PersonalityInsights.empty();
    }

    // Analyze patterns
    final emotionalPatterns = _analyzeEmotionalPatterns(allMemories);
    final activityPatterns = _analyzeActivityPatterns(allMemories);
    final socialPatterns = _analyzeSocialPatterns(allMemories);

    return PersonalityInsights(
      traits: profile.traits,
      interests: profile.interests,
      values: profile.values,
      emotionalPatterns: emotionalPatterns,
      activityPatterns: activityPatterns,
      socialPatterns: socialPatterns,
      totalMemories: allMemories.length,
      lastUpdated: profile.lastUpdated,
    );
  }

  Map<String, dynamic> _analyzeEmotionalPatterns(List<Memory> memories) {
    if (memories.isEmpty) return {};

    final emotions = <String, int>{};
    double totalWeight = 0.0;

    for (final memory in memories) {
      totalWeight += memory.emotionalWeight;
      
      // Since contexts are now List<String>, we look for emotion-related keywords
      for (final context in memory.contexts) {
        // Simple emotion detection from context strings
        final emotionKeywords = ['happy', 'sad', 'angry', 'excited', 'calm', 'stressed', 'joy', 'fear', 'love', 'hope'];
        for (final emotion in emotionKeywords) {
          if (context.toLowerCase().contains(emotion)) {
            emotions[emotion] = (emotions[emotion] ?? 0) + 1;
          }
        }
      }
    }

    final avgEmotionalWeight = totalWeight / memories.length;
    
    return {
      'average_emotional_weight': avgEmotionalWeight,
      'dominant_emotions': emotions,
      'emotional_stability': _calculateEmotionalStability(memories),
    };
  }

  Map<String, dynamic> _analyzeActivityPatterns(List<Memory> memories) {
    if (memories.isEmpty) return {};

    final activities = <String, int>{};
    final timePatterns = <String, int>{};

    for (final memory in memories) {
      // Extract activities and time patterns from context strings
      for (final context in memory.contexts) {
        // Simple pattern matching for activities
        final activityKeywords = ['work', 'study', 'exercise', 'read', 'write', 'cook', 'travel', 'meeting', 'call'];
        for (final activity in activityKeywords) {
          if (context.toLowerCase().contains(activity)) {
            activities[activity] = (activities[activity] ?? 0) + 1;
          }
        }
        
        // Simple pattern matching for time
        final timeKeywords = ['morning', 'afternoon', 'evening', 'night', 'weekend', 'weekday'];
        for (final time in timeKeywords) {
          if (context.toLowerCase().contains(time)) {
            timePatterns[time] = (timePatterns[time] ?? 0) + 1;
          }
        }
      }
    }

    return {
      'preferred_activities': activities,
      'active_times': timePatterns,
      'activity_diversity': activities.length,
    };
  }

  Map<String, dynamic> _analyzeSocialPatterns(List<Memory> memories) {
    if (memories.isEmpty) return {};

    final relationships = <String, int>{};
    int socialMemories = 0;

    for (final memory in memories) {
      bool isSocial = false;
      
      for (final context in memory.contexts) {
        // Simple pattern matching for social/relationship contexts
        final socialKeywords = ['friend', 'family', 'colleague', 'partner', 'team', 'group', 'social', 'meeting', 'call', 'chat'];
        for (final keyword in socialKeywords) {
          if (context.toLowerCase().contains(keyword)) {
            relationships[keyword] = (relationships[keyword] ?? 0) + 1;
            isSocial = true;
          }
        }
      }
      
      if (isSocial) socialMemories++;
    }

    final socialRatio = memories.isNotEmpty ? socialMemories / memories.length : 0.0;

    return {
      'relationship_types': relationships,
      'social_memory_ratio': socialRatio,
      'social_engagement_level': _categorizeSocialLevel(socialRatio),
    };
  }

  double _calculateEmotionalStability(List<Memory> memories) {
    if (memories.length < 2) return 0.5;

    final weights = memories.map((m) => m.emotionalWeight).toList();
    final mean = weights.reduce((a, b) => a + b) / weights.length;
    final variance = weights.map((w) => (w - mean) * (w - mean)).reduce((a, b) => a + b) / weights.length;
    
    // Convert variance to stability score (lower variance = higher stability)
    return (1.0 - variance.clamp(0.0, 1.0)).clamp(0.0, 1.0);
  }

  String _categorizeSocialLevel(double ratio) {
    if (ratio >= 0.7) return 'Highly Social';
    if (ratio >= 0.4) return 'Moderately Social';
    if (ratio >= 0.2) return 'Somewhat Social';
    return 'Introverted';
  }
}

// Data class untuk personality insights
class PersonalityInsights {
  final Map<String, double> traits;
  final List<String> interests;
  final List<String> values;
  final Map<String, dynamic> emotionalPatterns;
  final Map<String, dynamic> activityPatterns;
  final Map<String, dynamic> socialPatterns;
  final int totalMemories;
  final DateTime lastUpdated;

  PersonalityInsights({
    required this.traits,
    required this.interests,
    required this.values,
    required this.emotionalPatterns,
    required this.activityPatterns,
    required this.socialPatterns,
    required this.totalMemories,
    required this.lastUpdated,
  });

  factory PersonalityInsights.empty() {
    return PersonalityInsights(
      traits: {
        'openness': 0.5,
        'conscientiousness': 0.5,
        'extraversion': 0.5,
        'agreeableness': 0.5,
        'neuroticism': 0.5,
      },
      interests: [],
      values: [],
      emotionalPatterns: {},
      activityPatterns: {},
      socialPatterns: {},
      totalMemories: 0,
      lastUpdated: DateTime.now(),
    );
  }

  // Helper getters
  String get dominantTrait {
    if (traits.isEmpty) return 'Balanced';
    
    final sortedTraits = traits.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return _traitDisplayName(sortedTraits.first.key);
  }

  String get personalitySummary {
    final dominant = dominantTrait;
    final interestCount = interests.length;
    final memoryCount = totalMemories;
    
    return 'Primary trait: $dominant • $interestCount interests • $memoryCount memories';
  }

  List<String> get topInterests => interests.take(5).toList();
  List<String> get coreValues => values.take(3).toList();

  String _traitDisplayName(String trait) {
    switch (trait) {
      case 'openness': return 'Creative & Open';
      case 'conscientiousness': return 'Organized & Goal-oriented';
      case 'extraversion': return 'Social & Energetic';
      case 'agreeableness': return 'Cooperative & Kind';
      case 'neuroticism': return 'Emotionally Sensitive';
      default: return 'Balanced';
    }
  }
}

// Import statement yang diperlukan untuk HiveMemory
